---
title: "myrmd"
author: "LB"
date: "7 august 2016"
output: html_document
---

## Loading and preprocessing data

```{r, include=TRUE}
activity_data <- read.csv("activity.csv")
```

### Omitting na rows
```{r, include=TRUE}
activity_no_NA <- na.omit(activity_data)
```

## Steps per day

### Aggregating steps on for days
```{r, include=TRUE}
sinad <- aggregate(steps ~ date, activity_no_NA, sum) 
```

### Drawing a histogram of the number of steps in a day
```{r, include=TRUE}
hist(sinad[,2], breaks=26, col="green", main="Histogram of steps in a day", xlab="Steps")
```

### Summarizing the steps per day data
```{r, include=TRUE}
summary(sinad[,2])
```

## Average daily pattern

### Aggregating data on interval

```{r, include=TRUE}
sinint <- aggregate(steps ~ interval, activity_no_NA, sum) 
```
### Plotting the activity
```{r, include=TRUE, echo=TRUE}
plot(sinint, type='l', col="blue", main="Activity in time interval in a day")
```

### Finding the interval with the max value
```{r, include=TRUE}
which.max(sinint[,2])
sinint[104,]
```

## Dealing with missing values

### Counting the number

Use the boolean function is.na, and sum the 1-s to get the number

1. Create a function to look up interval averages depending on the recorded time
2. Mutate activity_data to include the above information in NA cases

```{r}
library(dplyr)
myf<-function(x){y<-sinint[which(sinint[,1]==x),2];   return (y/61)}
intervals <- sapply(activity_data[,3], myf)
activity_data %>% mutate(steps = ifelse(is.na(steps), intervals  ,steps)) -> activity_data_augment
```

### Making a histogram of the total number of steps taken
```{r}
augsinad <- aggregate(steps ~ date, activity_data_augment, sum) 
hist(augsinad[,2], breaks=26, col="cyan", main="Histogram of steps in a day with augmented values", xlab="Steps")
summary(augsinad)
```

## Weekdays and weekends

### Calculate new aggegrate data on the intervals and put in new factor variable
```{r}
activity_data_augment %>% mutate(daytype = ifelse( weekdays(as.Date(date))<"Fri" , "weekend", "weekday")) -> activity_data_augment
activity_data_augment %>% mutate(daytype = ifelse(weekdays(as.Date(date))<"Mon" , "weekend", "weekday")) -> activity_data_augment
activity_data_augment$daytype <- as.factor(activity_data_augment$daytype)

augsininit <- aggregate(steps ~ interval, activity_data_augment, sum) 
```

### Separate out factors, and plot them so both the daytype and days intervals can be generated.  Likely possible to do this in one operation.

```{r}
wd <- activity_data_augment[activity_data_augment$daytype == "weekday",]
we <- activity_data_augment[activity_data_augment$daytype == "weekend",]
wda <- aggregate(steps ~ interval, wd, mean)
wea <- aggregate(steps ~ interval, we, mean)
```

### Create the actual plots
```{r}
par(mfrow=c(2,1))
plot(wda, type='l', main="Weekdays", col="cyan")
plot(wea, type='l', main="Weekends", col="magenta")
```







